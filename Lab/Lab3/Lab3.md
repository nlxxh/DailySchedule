## Lab3学习报告

### 从虚拟内存到物理内存

#### 虚拟地址和物理地址

* 物理地址：物理地址就是内存单元的绝对地址
  * 帧：物理页面，把物理地址空间划分为大小相同的基本分配单位，每个物理页帧大小为4KB
* 虚拟地址：虚拟地址是操作系统给运行在用户态的应用程序看到的假地址
  * 页：虚拟页面，把逻辑(虚拟)地址空间划分为大小相同的基本分配单位，每个虚拟页面大小为4KB
* 转换：在程序中通过虚拟地址假想着自己在访问一块虚拟内存的时候，需要有一种机制，将虚拟地址转化为物理地址，交给 CPU 来根据它到物理内存上进行实打实的访问。而这种将虚拟地址转化为物理地址的机制，在 riscv64 中是通过页表来实现的
* Sv39物理地址：Sv39物理地址有56位
  * `PPN`：物理页号(帧号)，`page offset`：帧内偏移
  * 物理地址=`PPN*4K+page offset`
  
|PPN[2]               |PPN[1]               |PPN[0]               |page offset          |
|---------------------|---------------------|---------------------|---------------------|
|26                   |9                    |9                    |12                   |
* Sv39虚拟地址：Sv39虚拟地址有64位，但是只有低39位有效，规定63-39位的值必须等于第38位的值，否则会认为该虚拟地址不合法，在访问时会产生异常
  * `VPN`：虚拟页号，`page offset`：页内偏移
  * 虚拟地址=`VPN*4K+page offset`

|VPN[2]               |VPN[1]               |VPN[0]               |page offset          |
|---------------------|---------------------|---------------------|---------------------|
|9                    |9                    |9                    |12                   |
* 要实现虚拟地址到物理地址的映射，就是虚拟页到物理帧的映射，而页内偏移`page offset`等于帧内偏移`page offset`，也就是要实现虚拟页号`VPN`到物理帧号`PPN`的映射，这就是页表所做的事情

#### 页表项
* 如果一个虚拟页号通过某种手段找到了一个页表项`PTE`，并通过读取上面的物理帧号完成映射，我们称这个虚拟页号通过该页表项完成映射
* Sv39页表项：Sv39里面的一个页表项大小为64位8字节，其中第53-10共44位为一个物理页号，表示这个虚拟页号映射到的物理页号。后面的第9-0位则描述映射的状态信息

|Reserved             |PPN                  |Flags                |
|---------------------|---------------------|---------------------|
|10                   |44                   |10                   |

#### 多级页表

* 在Sv39中采用三级页表，即将27位的虚拟页号分为三个等长的部分，`VPN[2]`为三级索引，`VPN[1]`为二级索引，`VPN[0]`为一级索引
* 页表也分为三级页表，二级页表，一级页表，页表的大小和一个物理帧的大小相同，所以可以把一个页表放到一个物理页帧中，并用一个物理页号来描述它
  * 三级页表的物理页号为`PPN3`，三级页表的每个页表项中的物理页号`PPN2`可描述一个二级页表；二级页表的每个页表项中的物理页号`PPN1`可描述一个一级页表；一级页表的每个页表项中的物理页号`PPN0`描述一个要映射到的物理页
* 虚拟页号映射到物理帧号的流程：
  * 索引控制虚拟页号范围在`(VPN[2],Any,Any)`的三级页表项，其地址为`PPN3*4K+VPN[2]*8`，从这个页表项里读出二级页表的物理页号`PPN2`
  * 索引控制虚拟页号范围在`(VPN[2],VPN[1],Any)`的二级页表项，其地址为`PPN2*4K+VPN[1]*8`，从这个页表项里读出二级页表的物理页号`PPN1`
  * 索引控制虚拟页号范围在`(VPN[2],VPN[1],VPN[0])`的一级页表项，其地址为`PPN1*4K+VPN[0]*8`，从这个页表项里读出的物理页号`PPN0`就是虚拟页号`(VPN[2],VPN[1],VPN[0])`所要映射到的物理页号
  
#### 页表基址
  
* 页表的基址(起始地址)一般会保存在一个特殊的寄存器中。在 RISC-V 中，这个特殊的寄存器就是页表寄存器 satp
  * MODE: 控制CPU使用哪种页表实现，MODE设置为8即表示CPU使用Sv39 
  * PPN：存放三级页表所在的物理页号`PPN3`。这样，给定一个虚拟页号，CPU 就可以从三级页表开始一步步的将其映射到一个物理页号
  
| MODE                |ASID                 |PPN                  |
|---------------------|---------------------|---------------------|
|4                    |16                   |44                   |

#### 快表TLB

* 快表TLB：记录近期已完成的虚拟页号到物理页号的映射，提高效率
  * 如果修改了`satp`寄存器或者修改了一个页表项，就改变了映射方式，需要进行`sfence.vma`指令刷新整个TLB
  * `sfence.vma`指令不加参数，会刷新整个TLB，如果在后面加上一个虚拟地址，只刷新这个虚拟地址的映射

### 修改内核

#### 把内核代码转移到虚拟地址空间
* linker.ld：将内核代码放在虚拟地址空间中以`0xffffffff80200000`开头的一段高地址空间中，即原来放在`0x80200000`起始地址的全部内核结构被平移到了`0xffffffff80200000`的地址上，映射关系为：虚拟地址减去偏移量`0xffffffff00000000`为原来的物理地址，满足线性映射
```
BASE_ADDRESS = 0xffffffff80200000; /* 内核的基址修改为虚拟地址 */
```
```
. = ALIGN(4K); /* 加入对齐，不同的段放在不同的页上，标注各自特定的属性 */
```
* memory/config.rs：`KERNEL_END_ADDRESS`修改为虚拟地址并加入偏移量
```
lazy_static! {
    ///可以用来分配的内存起始地址修改为虚拟地址
    pub static ref KERNEL_END_ADDRESS: VirtualAddress = VirtualAddress(kernel_end as usize); 
}

/// 内核使用线性映射的偏移量
pub const KERNEL_MAP_OFFSET: usize = 0xffff_ffff_0000_0000;
```
* 当 OpenSBI 启动完成之后：
  * CPU 状态：处于 S Mode ，寄存器 `satp` 的 MODE 字段被设置为 Bare 模式，即无论取指还是访存我们通过物理地址直接访问物理内存
  * 因为 `linker.ld`，代码中 `boot_stack_top` 、`rust_main` 等符号的地址都是虚拟地址（高地址）
目前 CPU 将地址都当成物理地址处理，这样，我们跳转到 `rust_main` 就会跳转到 `0xffffffff00000000+` 的一个物理地址，导致问题，所以要修改 `entry.asm`， 恰当构造页表，来对于内核所属的虚拟地址，实现这种虚拟地址到物理地址的映射，这里构造的是最简单的大页，实现 `0xffff_ffff_8000_0000 -> 0x8000_0000`，只需要分配一页内存用来存放三级页表`boot_page_table`

* entry.asm：在进入`rust_main`之前完成一个从物理地址访存模式到虚拟访存模式的转换
```
_start:
    # t0 存储 boot_page_table 的虚拟地址
    lui t0, %hi(boot_page_table) 
    li t1, 0xffffffff00000000
    # t0 存储 boot_page_table 的物理地址
    sub t0, t0, t1
    # t0 存储 boot_page_table 的物理页号，相当于物理地址除以4K
    srli t0, t0, 12
    # 8 << 60 是 satp 中使用 Sv39 模式的记号
    li t1, (8 << 60)
    or t0, t0, t1
    # 写入 satp 并更新 TLB，此时 satp 表示使用 Sv39 模式，且 PPN 存放页表 boot_page_table 的物理页号
    csrw satp, t0
    sfence.vma
    # 已经搭建出了一个虚拟内存空间
```
```
# 启动时的一个简单页表，内核初始映射
boot_page_table:
    .quad 0
    .quad 0
    # 第 2 项：0x8000_0000 -> 0x8000_0000，0xcf 表示 VRWXAD 均为 1
    .quad (0x80000 << 10) | 0xcf
    .zero 507 * 8
    # 第 510 项(510 的二进制是要索引虚拟地址的 VPN[2]，注意虚拟地址的第30-38位为VPN[2])：0xffff_ffff_8000_0000 -> 0x8000_0000，0xcf 表示 VRWXAD 均为 1，表示 1GB 的一个大页
    .quad (0x80000 << 10) | 0xcf
    .quad 0
```
* 综上，要进入虚拟内存访问方式，需要如下步骤：
  * 分配页表所在内存空间并初始化页表
  * 设置好页基址寄存器（指向页表起始地址）
  * 刷新 TLB



