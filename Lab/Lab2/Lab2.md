## Lab2学习报告

### 动态内存分配

#### Buddy System

* 算法介绍：一种连续内存分配算法，每次分配的时候都恰好分配一块大小是`2`的幂次的内存，且要保证内存的开头地址需要是对齐的，也就是内存的开头地址需要是这块内存大小的倍数
* 分配内存：寻找大小合适的内存块(大于等于所需大小并且最接近2的幂)
  * 如果找到了，分配给应用程序
  * 如果没找到，分出合适的内存块
    * 对半分离出高于所需大小的空闲内存块
    * 如果分到最低限度，分配这个大小
    * 重复该步骤直到一个合适的块
* 实现思路：线段树(在每个线段树节点上存当前区间上所能够分配的最大`2`的幂次的内存大小`m`)`
  * 找到合适的内存块：为了尽可能满足分配的对齐需求，先尝试右子树，再尝试左子树，直到找到一个节点满足这个区间够分配，且它的左右子区间都不够分配，就将这个区间整体分配出去，将当前区间的`m`值改为`0`
  * 标注可选的内存块：左右子区间有已经分配出去的，自下而上进行`m`值的更新，`pa.m<-max(ls.m,rs.m)`
  * 回收时只需找到分配时的那个节点，将其`m`值改回去，同时同样自下而上进行`m`值更新即可
* 本实验直接使用开发好的 `buddy system allocator`
```
//这段空间编译后会被放在操作系统执行程序的 bss ，因为这段是一个静态的没有初始化的数组，作为提供给动态分配器的内存
static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE];
```
```
//堆的动态内存分配器
#[global_allocator]
static HEAP: LockedHeap = LockedHeap::empty();
```
```
// 告诉分配器使用这一段预留的空间作为堆
unsafe {
    HEAP.lock().init(
        HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE
    )
}
```
### 物理内存探测

* 默认的 DRAM 物理内存地址范围就是 `[0x80000000,0x88000000)`
  * 物理地址空间 `[0x80000000,0x80200000)` 被 OpenSBI 占用
  * 物理地址空间 `[0x80200000,KernelEnd)` 被内核各代码与数据段占用
  * 可以用来分配内存的物理地址范围是：`[KernelEnd, 0x88000000)`
    *`KernelEnd`为内核代码结尾的物理地址在，由 `linker.ld` 指定
```
lazy_static! {
    /// 内核代码结束的地址，即可以用来分配的内存起始地址
    /// 因为 Rust 语言限制，我们只能将其作为一个运行时求值的 static 变量，而不能作为 const
    pub static ref KERNEL_END_ADDRESS: PhysicalAddress = PhysicalAddress(kernel_end as usize);
}
extern "C" {
    /// 由 `linker.ld` 指定的内核代码结束位置
    /// 作为变量存在 [`KERNEL_END_ADDRESS`]
    fn kernel_end();
}
```
### 物理内存管理

#### 物理页
* 通常，我们在分配物理内存时并不是以字节为单位，而是以一物理页(Frame)，即连续的 `4 KB` 字节为单位分配。我们希望用物理页号(PPN)来代表一物理页，实际上代表物理地址范围在`[PPN×4KB,(PPN+1)×4KB)`的一物理页
* 物理页号与物理页形成一一映射，为了能够使用物理页号这种表达方式，每个物理页的开头地址必须是 `4 KB`的倍数
#### 分配和回收
* `FrameTracker`：在内存中划一片连续区域，作为一个物理帧的标识
